# 通过逻辑复制升级到PostgreSQL 11

> 本文翻译自[Upgrading to PostgreSQL 11 with Logical Replication](https://blog.2ndquadrant.com/upgrading-to-postgresql-11-with-logical-replication/ )



大约一年前，我们发布了支持本机逻辑复制的PostgreSQL 10。逻辑复制的用途之一是允许在PostgreSQL的主要版本之间低停机或不停机地进行升级。到目前为止，PostgreSQL 10是唯一具有本机逻辑复制的PostgreSQL版本，所以用这种方式进行升级的机会并不多。（逻辑复制也可以用于在不同操作系统或CPU架构上的实例之间数据迁移，这些实例可能使用不同的配置设置，例如块大小或区域设置）既然PostgreSQL 11发布在即，那么就有更多使用这项功能的理由了。

升级PostgreSQL安装的三种主要方法：

- pg_dump和restore
- pg_upgrade
- 逻辑复制

我们可以在稳定性，速度，停机所需时间和限制条件（还有更多，暂不列举）等方面进行比较。

pg_dump和restore可以说是最强大的方法，这种方法经过了最多的测试并且已经使用了数十年之久。对于它的限制也很少。它可以构建无法转储和恢复的数据库，主要是涉及特定的对象依赖关系的，但这些数据库是极少的，并且一般涉及很复杂的操作。

dump和restore方法的问题在于，它需要在dump和restore操作运行的整个过程中停机。虽然源数据库在进程运行时仍然可读可写，但是对源数据库的任何更新在转储开始之后都会丢失。

pg_upgrade通过直接移动数据文件来优化pg_dump进程，而不是将它们转储为逻辑文本形式。请注意，pg_upgrade仍在内部使用pg_dump来复制架构，但不复制数据。当pg_upgrade功能刚发布时，它的稳定性受到质疑，而且也确实在升级数据库出现了一些错误。但是pg_upgrade现在经过了充分的测试已经非常成熟了，所以不必再因为这个原因而犹豫是否使用它。当运行pg_upgrade时，数据库系统是关闭的。但是我们可以选择pg_upgrade运行多长时间。在默认复制模式下，总运行时间由转储和恢复架构的时间（通常非常快，除非有数千个表或其他对象）加上复制数据文件的时间组成，这取决于数据库有多大（和I/O系统，文件系统，等等。）

在可选链接模式下，数据文件被硬链接到新的数据目录，因此，仅仅是对每个文件执行一个简短的内核操作，而不是复制每个字节。缺点是如果升级出现任何问题或者需要回退到安装开始的状态，此操作将会破坏原来的数据库。（我正在研究通过使用reflinks或者支持文件系统的文件克隆为PostgreSQL 12开发一个两全其美的解决方案。）

逻辑复制是最新的功能，因此可能需要一些时间来解决问题。（当然，很多年来人们一直在使用其他非核心逻辑复制解决方案，如Slony，Londiste和pglogical，来升级PostgreSQL，这些方案的很多经验也是可以参考的。） 

使用逻辑复制进行升级的优点是，在数据同步时，应用程序可以继续针对旧实例运行。在客户端的连接被切换时只需要中断很短的时间。因此，虽然使用逻辑复制升级可能比在复制模式下使用pg_upgrade要慢（并且肯定比使用硬链接模式慢），但并不重要，因为实际的停机时间要短得多。 

请注意，逻辑复制当前不会复制架构的改变。用这种升级过程，架构仍然通过pg_dump来复制，但后续架构的改变不会被继承。使用逻辑复制进行升级还有一些其他限制。逻辑复制不捕获某些操作：大对象，TRUNCATE，序列更改。我们稍后将讨论这些问题的解决方法。 

以上这些方法之间也存在一些差异。无论使用哪种方法，都需要为升级后的实例做新的物理备份。通过转储和还原以及逻辑复制，可以在升级开始之前将它们放置到位，是为了恢复或逻辑复制初始同步一旦完成，备份就可以准备好，否则就会受到复制延迟的影响。 

使用pg_upgrade，必须在主服务器升级完成后创建新的备份。（pg_upgrade文档更详细地描述了这一点。）如果依靠物理备份实现高可用，则在切换到新实例之前，备份应该就位，因此备份的设置可能会影响整体计时的计算。 

以下是使用逻辑复制进行升级的步骤： 

1.旧实例必须为逻辑复制做好准备。这需要一些配置设置，如[https://www.postgresql.org/docs/10/static/logical-replication-config.html](https://www.postgresql.org/docs/10/static/logical-replication-config.html)所述（主要是`wal_level = logical`。如果你需要进行这些修改，则需要重启服务器，所以在这之前请仔细检查。同时检查旧实例的`pg_hba.conf`是否设置为接受来自新实例的连接。（更改只需要重新加载。） 

2.安装新的PostgreSQL版本。

3.初始化一个新实例，即运行initdb。新实例可以具有与旧实例不同的设置，例如区域设置，WAL段大小等。

4.在启动新实例之前，您可能需要更改某些设置。如果新实例与旧实例在同一主机上运行，则需要设置不同的端口号。此外，在旧实例的`postgresql.conf`上所做的任何更改也会被继承，例如内存设置`max_connections`等。同样，设置`pg_hba.conf`来适合你的环境。如果要使用SSL，也可以进行设置。 

5.启动新的（空）实例并检查它是否满足你的要求。如果你在新主机上设置新实例，请在此时检查是否可以从新主机连接到旧数据库实例（使用psql）。我们将在后续步骤中使用它。 

6.使用pg_dumpall复制架构定义。（或者你可以分别通过为每个数据库使用pg_dump来实现，但不要忘记角色等全局对象。） 

```shell
pg_dumpall -s > schemadump.sql
psql -d postgres -f schemadump.sql 
```

这步操作之后的任何架构的更改都不会迁移。在许多情况下，只需在两台主机上使用更改的DDL，但在升级期间运行更改表结构的命令可能会出现麻烦。 

7.在源实例的每个数据库中，创建一个publication来捕获所有表： 

```plsql
CREATE PUBLICATION p_upgrade FOR ALL TABLES;
```

逻辑复制在每个数据库中单独工作，因此需要在每个数据库中重复这一过程。另一方面，不必一次升级所有数据库，一次只在一台数据库上执行即可，甚至不用升级很多台。 

8.在目标实例的每个数据库中，创建subscription用来订阅刚创建的publication。确保正确匹配源数据库和目标数据库。 

```plsql
CREATE SUBSCRIPTION s_upgrade CONNECTION 'host=oldhost port=oldport dbname=dbname ...' PUBLICATION p_upgrade;
```

根据需要设置连接参数。 

9.现在你要等到subscription 同步了初始数据并完全赶上了publication。您可以检查系统目录`pg_subscription_rel`（在`srsubstate`列中查找`r`= ready ）中订阅中每个表的初始同步状态。可以在发送方的`pg_stat_replication`和接收方`pg_stat_subscription`中检查复制的总体状态。 

10.如上所述，序列更改不会被复制。一种可行的解决方法是使用pg_dump复制序列值。你可以使用以下内容获得当前序列值的转储： 

```shell
pg_dump -d dbname --data-only -t '* _seq' > seq-data.sql
```

（假设序列名称全部匹配`*_seq`，并且没有表匹配该名称。在更复杂的情况下，你还可以通过创建完整转储并从转储目录中提取序列数据。） 

由于在你执行此操作时序列可能会向前推进，所以可能需要对`seq-data.sql`文件中的数字进行munge算法处理来添加一定的空间。 

然后使用psql将该文件恢复到新数据库。 

11.Showtime：将应用程序切换到新实例。这是一开始就需要想到的。在最简单的方案中，停止你的应用程序，更改连接设置，重新启动。如果你使用了连接代理，则可以在那里切换连接。您还可以一个接一个地切换客户机应用程序，也许是为了测试一下，或者减轻新系统上的负载。只要仍然指向旧服务器的应用程序和指向新服务器的应用程序不会产生冲突的写入，就没有问题。（在这种情况下，你将运行一个多主机系统，至少在很短的时间内。） 

12.升级完成后，您可以拆除复制设置。在新实例的每个数据库中，运行 

```plsql
DROP SUBSCRIPTION s_upgrade;
```

如果已关闭了旧实例，则会失败，因为它无法访问远程服务器来删除复制槽。有关如何在此情况下继续操作，请参阅[DROP SUBSCRIPTION](https://www.postgresql.org/docs/11/static/sql-dropsubscription.html)手册页。 

也可以删除源实例上的publications，但这不是必需的，因为publication不保留资源。 

13.最后，如果您不再需要它们，请删除旧实例。 

有关于逻辑复制不支持事项的解决办法，后面是一些附加注释。如果需要使用大型对象，则可以使用pg_dump来移动它们，当然只要它们在升级过程中不会更改就可以。这是一个重要的限制，因此如果你是大型对象的重度用户，则此方法可能不适合你。如果你的应用程序在升级过程中发出TRUNCATE，则不会复制这些操作。也许你可以调整应用程序以防止它在升级时执行此操作，或者可以替换DELETE。PostgreSQL 11将支持复制TRUNCATE，但只有在源实例和目标实例都是PostgreSQL 11版本或更新的版本时才会有效。 

真正适用于所有升级承诺的结束语： 

- 在投入生产之前，应该针对新的主PostgreSQL版本来测试应用程序和所有数据库客户端程序。
- 为实现这一目标，你还应该在生产环境中执行升级过程之前来测试升级过程。
- 尽可能的自动化。
- 确保在升级过程中适当调整备份设置、监视系统以及任何的维护工具和脚本。理想情况下，这些应该在切换完成之前就位并进行验证。
