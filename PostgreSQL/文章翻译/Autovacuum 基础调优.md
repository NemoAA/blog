# **Autovacuum 基础调优**

本文翻译自[Autovacuum Tuning Basics](https://blog.2ndquadrant.com/autovacuum-tuning-basics/#PostgreSQL%20Performance%20Tuning)

几周前，我介绍了调优检查点的基础知识，在那篇文章中，我还提到了性能问题的第二个常见来源是`autovacuum`(根据我们在邮件列表中看到的内容以及我们的客户在support下看到的内容)。所以让我在这篇关于`autovacuum`基础调优的文章中继续。我将非常简要地解释必要的理论(`dead tuples`、`bloat`以及`autovacuum`如何处理它们)，但这篇博客文章的主要焦点是调优——有哪些配置选项、经验法则等等。

## **1.Dead tuples**

首先，简单的解释一下什么是 `dead tuples`和`bloat`。

当你在PostgreSQL中做`DELETE`操作，行（也叫做元组（`tuples`）），是没有立即从数据文件中移除的，仅仅是通过在行头部设置`xmax`做一个删除标记。`Update`操作也是一样的，在PostgreSQL中可以看作先`DELETE`再`INSERT`。

这是PostgreSQL MVCC的基本思想之一，因为它允许在不同进程之间只进行最小的锁定就可以实现更大的并发性。这个MVCC实现的缺点当然是它会留下被标记删除的元组（`dead tuples`），即使在看到这些版本完成的所有事务之后。

如果不清理掉，那些`dead tuples` （对任何事务都是不可见的）将会永远留在数据文件中，浪费磁盘空间，对于表来说，有过多的删除和更新，`dead tuples`很容易占绝大部分磁盘空间。而且`dead tuples`也会在索引中存在，更加加重磁盘空间的浪费。这既是我们在PostgreSQL中常说的膨胀（`bloat`）。自然的，需要处理的数据查询越多(即使99%的数据被立即打上了"死亡"标记)，查询的速度就越慢。

## 2.VACUUM **与** autovacuum

回收`dead tuples`占用的空间(并使其对新行可用)最直接的方法是手动运行`vacuum`命令。这个维护命令将扫描表并从表和索引中删除`dead tuples` ——它通常不会将磁盘空间返回给操作系统，但它将使它对新行可用。

**注意**:`vacuum full`会回收空间并返回给操作系统，但是它有很多缺点。首先，它会产生独占锁，阻塞所有操作(包括`select`)。其次，它实际上创建了一个表的副本，使所需的磁盘空间加倍，因此当系统可用磁盘空间很少时，它就不太实用了。

`vacuum`的问题在于它完全是手动操作——只有当你决定运行它时才会发生，而不是在需要的时候。你可以将其放入计划任务中，并在所有表上每5分钟运行一次，但是大多数运行并不会真正清理任何东西，唯一的影响是系统上更高的CPU和I/O使用率。或者可以一天只在晚上运行一次，在这种情况下，可能会积累更多的`dead tuples` 。

这就引出了`autovacuum`的主要目的;根据需要进行清理，以控制浪费的空间数量。数据库知道在一段时间内生成了多少个死元组(每个事务报告它删除和更新的元组的数量)，因此当表累积一定数量的`dead tuples` 时(默认情况下，这是表的20%)可以触发清理。因此，它将在繁忙期间更频繁地执行，而在数据库大部分处于空闲状态时很少执行。

## 3.autoanalyze

清除`dead tuples` 并不是`autovacuum`的唯一任务。它还负责更新数据分布统计信息，优化器在规划查询时使用这些统计信息。您可以通过运行`ANALYZE`手工收集这些数据，但是它也有与`VACUUM`类似的问题——您可能经常运行它，也可能不经常运行。

解决方法也是相似的，数据库能够监视表中改变了多少行，然后自动的运行`analyze`。

**注意**：对于`analyze`来说，负面影响要更糟一些，虽然`vacuum`的执行成本与`dead tuples`的数量成正比(`dead tuples`很少的时候成本相当低)，但是`analyze`必须在每次执行时从头重新构建统计数据。另一方面，如果你不经常运行它，选择糟糕的执行计划带来的代价可能同样严重。

为了简洁起见，我将在这篇文章的其余部分忽略`autovacuum`这个词，用清理代理——无论如何，这个配置与清理相当相似，并且遵循大致相同的推理。

## **4.监控**

在进行任何类型的调优之前，需要能够收集相关数据——否则，如何说需要进行调优，或者评估配置更改的影响?

换句话说，应该有一些基本的监视，从数据库收集指标。为了进行清理，至少要查看以下值:

\* `pg_stat_all_tables.n_dead_tup` –每个表`dead tuples`的数量（包括用户表和系统表）、

\* `(n_dead_tup / n_live_tup)` –dead/live tuples在每个表中的比率

\* `(pg_class.relpages / pg_class.reltuples)` – 每一行的空间

如果已经部署了监视系统(也应该这样做)，那么很可能你已经在收集这些指标了。总体目标是获得一个稳定的状态，这些指标没有突然/显著的变化。

这是一个非常方便的扩展：[pgstattuple](https://www.postgresql.org/docs/current/static/pgstattuple.html) ，允许对表和索引执行`analyze`，包括计算空闲空间的数量、`dead tuples`等。

## **5.调优目标**

在查看实际的配置参数之前，让我们简要讨论一下什么是高级调优目标，即我们在更改参数时希望达到的目标:

- **清除`dead tuples`**-保持磁盘空间合理的较低的占用,不浪费磁盘空间,防止索引膨胀并保持快速查询。


- **让清除的影响减到最小**-不要太经常的执行清除，他将会浪费CPU、I/O、内存资源并且降低性能。


也就是说，你需要找到一个正确的平衡，因为执行过多或者执行过少都会有坏的影响。平衡在很大程度上取决于你管理的数据量、业务上的负载类型(删除/更新的数量)。

Postgresql.conf中的许多默认值是相当保守的，有两个原因：第一，默认值是几年前根据当时通用的配置(CPU、RAM、…)确定的。第二，我们希望默认配置可以在任何地方工作，包括像Raspberry Pi这样的小型机器或小型VPS服务器。对于许多部署(特别是较小的部署 和/或 处理以读为主的工作负载)，默认配置参数将正常工作。

随着数据库大小 和/或 写入量的增加，问题开始出现。典型的问题是清理工作并不经常发生或者当清理工作发生时并且它必须要处理大量垃圾时，它会严重影响性能。如果这些情况下，你应该遵循这个简单的规则:

*如果它对性能的影响很大，说明清理工作次数不足*。

那就需要调整参数让清理工作做得更频繁，减少每次处理`dead tuples`的数量。

**注意**：人们有时会遵循不同的规则——如果对性能的影响很大，就不要去做，并且完全关闭`autovacuum`。请不要这样做，除非你真的(真的真的)知道你在做什么，并且有定期的到位的清理脚本。否则，您将陷入困境，您将不得不处理严重的性能下降，甚至可能出现停机。

所以，现在我们知道通过调优要实现什么了，让我们看看配置参数 ...

## **6.阈值与比例因子**

当然，首先要调整的是清理工作何时被触发，这受到两个参数的影响:

- **autovacuum_vacuum_threshold** = 50

- **autovacuum_vacuum_scale_factor** = 0.2


```sql
当“dead tuples”的数量(可以从aspg_stat_all_tables.n_dead_tup看到) 
超过 
threshold + pg_class.reltuples * scale_factor时，表就会被认为需要清理，就会触发清理工作。
```

该公式表达的意思主要是：表中的`dead tuples`达到20%将会被清理，（50行的阈值是为了预防对微小的表非常频繁的清理）。

对于中小型表，默认的比例因子可以很好的工作在中小型表上，但是对于非常大的表就不那么好了——在10GB的表中，大约是2GB的`dead tuples`，而在1TB的表中，大约是200GB。

这是一个积累大量`dead tuples`的例子，并且一次处理所有的元组，这会很影响性能。根据前面提到的规则，解决方案是通过显著降低比例因子来更频繁地执行，甚至可能是这样:

```sql
autovacuum_vacuum_scale_factor = 0.01
```

它将把上限降低到只有表的1%。另一种解决方案是完全放弃比例因子，只使用阈值。

```
1 autovacuum_vacuum_scale_factor = 0
2 autovacuum_vacuum_threshold = 10000
```

这将在生成一万个`dead tuples`之后触发清理。

有一个问题是这些改变在postgresql.conf中，所以是影响所有的表（实际上是整个数据库集簇），我们可能不希望影响小表和系统表的清理。

当小表被更频繁地清理时，最简单的解决方案就是完全忽略这个问题。清理小表的成本相当低，而对大表的改进通常非常显著，即使忽略了小表上的清理成本，总体效果仍然非常积极。

但是，如果您决定以一种显著延迟小表清理的方式更改配置(例如设置`scale_factor`=0和`threshold`=10000)，那么最好只使用`ALTER TABLE`将这些更改应用于特定的表:

```sql
1 ALTER TABLE t SET (autovacuum_vacuum_scale_factor = 0);
2 ALTER TABLE t SET (autovacuum_vacuum_threshold = 10000);
```

尽量保持配置简单，并覆盖尽可能少的表的参数。在你的内部文档中包含这一点也是一个好主意，包括对特定值的推理。

## **7.限流**

`Autovacuum`一个相当好的特色是限流。清理是在后台运行的维护任务，对用户查询的影响最小。换句话说，它不应该消耗太多的资源(CPU和磁盘I/O)，这正是限流内置到`autovacuum`中的目的。

清理过程相当简单——它从数据文件中读取页面(8kB的数据块)，并检查是否需要清理。如果没有`dead tuples`，页面将被简单地丢弃，而不进行任何更改。否则，它将被清理(删除`dead tuples`)，被标记为“脏的”，并最终被写出来。成本计算是基于以下三个基本操作的成本定义的:

```
1 vacuum_cost_page_hit = 1
2 vacuum_cost_page_miss = 10
3 vacuum_cost_page_dirty = 20
```

也就是说，如果从shared_buffers读取页面，则计数为1。如果shared_buffers中没有找到它而需要从操作系统中读取，计数为10(它可能仍然由RAM提供，但我们不知道)。最后，如果页面被清理弄脏了，则计数为20。这让我们可以计算`autovacuum`的“工作成本”。

通过限制一次性完成的工作量(默认设置为200)来实现限流，每次清理工作完成这么多工作(计数达到`autovacuum_vacuum_cost_limit` )，它就会休眠20毫秒:

```sql
1 autovacuum_vacuum_cost_delay = 20ms
2 autovacuum_vacuum_cost_limit = 200
```

那么，实际上允许做多少工作呢?使用20ms延迟，清理工作每秒可以执行50轮，每轮200意味着每秒10000。这意味着:

- 每秒从share_buffer读80M（假设不脏）

- 每秒从操作系统读8M（也可能来自磁盘）

- 每秒写4M（被`autovacuum`进程弄脏的页）


考虑到当前硬件的能力，读/写大多是连续的，这些限制太低了。

我们通常做的是将`cost_limit`参数增加到1000(或2000)，这将使吞吐量增加5倍(或10倍)。当然，也可以调整其他参数(每页操作的成本、睡眠延迟)，但是我们很少这样做——更改成本限制就足够了。

## **8.进程数量**

还有一个配置选项还没有提到，那就是`autovacum_max_workers`，那是关于什么的呢?当然，清理不会在一个单独的`autovacuum`进程中发生，但是数据库可以启动到`autovacum_max_workers`个进程，这些进程实际上是在清理不同的数据库/表。

这很有用，因为例如，在清理单个大表完成之前，您不希望停止清理小表(这可能需要相当长的时间，因为进行了节流)。

这里有一个问题：用户认为进程的数量与可能发生的清理量成正比。如果你把`autovacuum`进程的数量增加到6个，它肯定会比默认的3个进程多做两倍的工作，这样对吗?

嗯,没有。前几段描述的成本限制是全局级别的，由所有的`autovacuum`进程共同承担。每个进程只会得到总成本限制的1/ `autovacum_max_workers`，因此增加进程数量只会让他们走得更慢。

这有点像高速公路——把汽车的数量增加一倍，但让它们以一半的速度行驶，每小时到达目的地的人数只会大致相同。

因此，如果数据库上的清理工作跟不上用户的活动，那么增加进程的数量并不是解决方案，除非您还调整其他参数。

## **9.针对于个别表的限流**

实际上，当我说成本限制是全局级别的，并且由所有的`autovacuum`进程共同承担时，我是有点儿撒谎的。与比例因子和阈值类似，可以设置每个表的成本限制和延迟:

```
1 ALTER TABLE t SET (autovacuum_vacuum_cost_limit = 1000);
2 ALTER TABLE t SET (autovacuum_vacuum_cost_delay = 10);
```

然后，处理此类表的进程不包括在全局成本计算中，而是独立地进行控制。​	

这给了你相当多的灵活性和权力，但别忘了——权力越大，责任越大!

在实践中，我们几乎从不使用这些特征，主要原因有两个：第一，您通常希望在后台清理中使用单个全局限制。其次，让多个进程一起工作，有时候会相互限流，有时单独工作，使得监控和分析系统的行为变得更加困难。

## **10.总结**

这就是调优`autovacuum`的方法。如果要我把它总结成几个基本的规则，那就是这5条:

- 不要禁用`autovacuum`，除非你真的知道你自己在做什么。很严肃。

- 在忙碌的数据库上（做大量的更新和删除），特别是大的数据库，应该减小比例因子，让清理发生的更频繁

- 在合理的硬件上（好的存储，多个核心），应该增加限流参数让清除工作不落后。

- 在大部分情况下，单独增加`autovacuum_max_worker`并没有真实的帮助。而且会让更多的进程变慢。

- 可以使用`alter table`设置单个表的参数，但请三思而后行。他会让你的系统变得更复杂也更难检查。


我最初列入了一些解释`autovacuum`不工作的情况的部分，以及如何检测它们(以及最好的解决方案是什么)，但是博客已经太长了，所以我将在几天内分别发布。